#!/usr/bin/env python3

#   This file is part of NEF Synaptic Computation
#   (c) Andreas St√∂ckel 2017, 2018
#
#   NEF Synaptic Computation is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   NEF Synaptic Computation is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, sys
import numpy as np
import subprocess
import tempfile
from ctypes import cdll, POINTER, Structure, pointer, \
                   c_double, c_size_t, c_uint64


class Params(Structure):
    """
    Class holding the simulation parameters of a two-compartment LIF neuron with
    conductance based synapses.
    """

    _fields_ = list(
        map(lambda x: (x, c_double), [
            "gC", "gLDen", "gLSom", "cmDen", "cmSom", "EE", "EI", "EL",
            "v_thresh", "tau_ref"
        ]))

    def __init__(self, *args, **kwargs):
        self.gC = 100e-9
        self.gLDen = 12.5e-9
        self.gLSom = 50e-9
        self.cmDen = 0.25e-9
        self.cmSom = 1.0e-9
        self.EE = 20e-3
        self.EI = -75e-3
        self.EL = -65e-3
        self.v_thresh = -50e-3
        self.tau_ref = 2e-3

        super(Params, self).__init__(*args, **kwargs)

def make_noise(tau, rate, T=1.0, dt=1e-4):
    """
    The make_noise function is responsible for generating noise equivalent to
    what would be generated by a filtered spike train with random spike weights
    and spike rate "rate".

    tau: filter size
    rate: input spike train rate
    T: length of the generated input in seconds
    dt: timestep of the generated output
    """
    n = int(T / dt + 1e-9)
    xs = np.empty(n, dtype=np.float64)
    f1 = 1.0 / (tau * rate)
    f0 = (1.0 - dt / tau)
    t = np.random.exponential(1.0 / rate)
    xs[0] = 1.0;
    for i in range(1, n):
        xs[i] = xs[i - 1] * f0
        t = t - dt
        while t < 0:
            xs[i] += f1 * np.random.uniform(0, 2)
            t += np.random.exponential(1.0 / rate)
    return xs

def simulate(gEs,
             gIs,
             state=None,
             params=None,
             T=1.0,
             dt=1e-4,
             record_iSyn=False):
    """
    Simulates a two-compartment LIF neuron and returns output spikes, synaptic
    currents, and the final state of the neuron. Note that the length of the
    input arrays gEs and gIs must be equal to the number of timesteps, which
    can be either computed as `int(T / dt + 1e-9)` or alternatively
    `len(np.arange(0, T, dt))`.

    gEs: list of input conductances in Siemens.
    gIs: list of output conductances in Siemens.
    state: initial state of the neuon. 3-element array consisting of the initial
    voltage of the dendridic compartment, the initial voltage of the somatic
    compartment, and the current refractory period. If None is given, the state
    is automatically initialised with the leak potential and zero for the
    current refractory period. The final state is returned as third return
    value.
    params: neuron parameters. If None is given, default parameters obtained
    with Params() are used.
    T: length of the simulation in seconds.
    dt: simulation timestep
    record_iSyn: if True, the synaptic current is recorded and returned as
    second return value. If False, None is returned as second return value.
    """

    def inv(A):  # Inverse of a 2x2 matrix
        a, c, b, d = A.flatten()
        det = a * d - b * c
        return np.array(((d, -c), (-b, a))) / det

    def expm(A, t):  # Matrix exponential of a positive definite 2x2 matrix
        a, c, b, d = A.flatten()

        D = np.sqrt(a * a + d * d - 2 * a * d + 4 * b * c)  # Discriminant

        lambda_1 = 0.5 * (d + a + D)
        lambda_2 = 0.5 * (d + a - D)

        c_1 = (2 * c / (d - a + D))
        c_2 = (2 * c / (d - a - D))
        c_d = c_1 - c_2

        e_1 = np.exp(lambda_1 * t)
        e_2 = np.exp(lambda_2 * t)

        return np.array(((c_1 * e_1 - c_2 * e_2,
                          -c_1 * e_1 * c_2 + c_2 * e_2 * c_1),
                         (e_1 - e_2, -c_2 * e_1 + c_1 * e_2))) / c_d

    # Create the output arrays, including voltage and current traces
    ts = np.arange(0, T, dt)
    spikes = np.zeros(len(ts))
    iSyns = None
    if (record_iSyn):
        iSyns = np.zeros(len(ts))

    # Input parameters
    params = Params() if params is None else params

    # Pre-compute some constants
    p = params  # Shorthand
    Ab = p.gC / p.cmDen
    Ac = p.gC / p.cmSom
    Ad = -(p.gLSom + p.gC) / p.cmSom
    b2 = p.EL * p.gLSom / p.cmSom

    # Iterate over all timesteps
    if state is None:
        state = np.array((p.EL, p.EL, 0.0))

    for i, t in enumerate(ts):
        # Fetch the input conductances
        gE = gEs[i]
        gI = gIs[i]

        # We have a differential equation of the form
        # d/dt x = Ax + b, where A is a 2x2 matrix, and b is a vector
        A = np.array(((-(gE + gI + p.gLDen + p.gC) / p.cmDen, Ab), (Ac, Ad)))
        b = np.array(((p.EE * gE + p.EI * gI + p.EL * p.gLDen) / p.cmDen, b2))

        # Solve at time dt
        # see https://en.wikipedia.org/wiki/Matrix_differential_equation
        vEq = -inv(A) @ b
        state[0:2] = vEq + expm(A, dt) @ (state[0:2] - vEq)

        # Implement the spike generation mechanism in the soma
        if state[1] > p.v_thresh:
            state[2] = p.tau_ref + dt
            spikes[i] = 1.0 / dt
        if state[2] > 0.0:
            state[1] = p.EL
            state[2] = np.maximum(0.0, state[2] - dt)
            if record_iSyn:
                iSyns[i] = np.nan
        elif record_iSyn:
            iSyns[i] = (state[0] - state[1]) * gC

    return spikes, iSyns, state


def from_biological_current(J, params=Params()):
    """
    Translates the synaptic currents produced by a two-compartment LIF neuron
    with biological parameters to the normalised space usually used inside the
    NEF.

    J: synaptic current as returned by two_compartment_lif.simulate()
    params: set of biological neuron parameters used in the two_compartment_lif
    simulation.
    """
    return -J / (params.gLSom * (params.EL - params.v_thresh))


def _make_native_simulate(libpath):
    # Load the compiled .so
    lib_two_compartment_lif = cdll.LoadLibrary(libpath)
    c_simulate_two_compartment_lif_conductances = \
        lib_two_compartment_lif.simulate_two_compartment_lif_conductances
    c_make_noise = lib_two_compartment_lif.make_noise

    def native_simulate(gEs,
                        gIs,
                        state=None,
                        params=None,
                        T=1.0,
                        dt=1e-4,
                        record_iSyn=False):
        # Number of timesteps
        n_samples = int(T / dt + 1e-9)
        assert (gEs.size == n_samples)
        assert (gIs.size == n_samples)

        # Input parameters
        params = Params() if params is None else params

        # Input arrays
        gEsf = gEs.astype(np.float64, copy=False)
        gIsf = gIs.astype(np.float64, copy=False)

        # If no state is given, start with the default state
        if state is None:
            state = np.array((params.EL, params.EL, 0.0))
        statef = state.astype(np.float64, copy=False)

        # Output array
        spikes = np.zeros(n_samples, dtype=np.float64)
        iSyns = np.zeros(n_samples, dtype=np.float64) if record_iSyn else None

        # Run the simulation
        c_double_p = POINTER(c_double)
        c_simulate_two_compartment_lif_conductances(
            pointer(params),
            gEsf.ctypes.data_as(c_double_p),
            gIsf.ctypes.data_as(c_double_p),
            statef.ctypes.data_as(c_double_p),
            spikes.ctypes.data_as(c_double_p),
            iSyns.ctypes.data_as(c_double_p) if record_iSyn else c_size_t(0),
            c_uint64(n_samples), c_double(dt))

        # Return the result arrays
        return spikes, iSyns, statef

    def native_make_noise(tau, rate, T=1.0, dt=1e-4):
        n = int(T / dt + 1e-9)
        xs = np.empty(n, dtype=np.float64)
        c_double_p = POINTER(c_double)
        c_make_noise(
            c_double(tau), c_double(rate), c_double(dt),
            xs.ctypes.data_as(c_double_p), c_uint64(n))
        return xs

    return native_simulate, native_make_noise


# Try to compile the C++ module into a temporary directory only read/writeable
# by the current user (which is kind of important when creating excutables)
libpath = os.path.join(tempfile.mkdtemp(), 'two_compartment_lif.so')

# Try to compile the library into the target directory
curdir = os.path.dirname(os.path.abspath(__file__))
if (subprocess.call(["make", "-s", "-C", curdir, "-e", "LIBPATH=" + libpath])
        != 0 or not os.path.isfile(libpath)):
    sys.stderr.write(
        "Compilation of {} failed, using Python fallback\n".format(libpath))
    sys.stderr.flush()
else:
    simulate, make_noise = _make_native_simulate(libpath)

# Cleanup the temporary directory when the interpreter exists
import atexit


@atexit.register
def delete_library():
    try:
        os.remove(libpath)
        os.remove(libpath + ".o")
        os.rmdir(os.path.dirname(libpath))
    except:
        pass  # Don't care if this operation fails


# Main program -- run a test simulation
if __name__ == '__main__':
    import matplotlib.pyplot as plt
    T = 1.0
    dt = 1e-5
    nts = int(T / dt + 1e-9)
    ts = np.arange(0.0, T, dt)
    gEs = np.ones(nts) * 2e-6
    gIs = np.ones(nts) * 0.1e-6
    spikes, _, state = simulate(gEs, gIs, T=T, dt=dt)

    noise = make_noise(5e-3, 1e3, T, dt);
    fig, ax = plt.subplots()
    ax.plot(ts, noise)

    plt.show()

    print(ts[spikes > 0])
    print(state)
    print(np.mean(noise))

